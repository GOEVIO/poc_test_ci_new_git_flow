import { ObjectId, AnyBulkWriteOperation } from 'mongodb';
import { DbConnection } from '../commons/connect';
import * as mongoose from 'mongoose';

const convertObjectIdToString = (data) => {
  if (typeof data === 'object' && data !== null) {
    for (const key in data) {
      if (data.hasOwnProperty(key)) {
        if (key === '_id') {
          data[key] = data._id?.toString();
        } else {
          data[key] = convertObjectIdToString(data[key]);
        }
      }
    }
  } else if (Array.isArray(data)) {
    data = data.map((item) => convertObjectIdToString(item));
  }
  return data;
};

const convertStringToObjectId = (data) => {
  if (typeof data === 'object' && data !== null) {
    for (const key in data) {
      if (data.hasOwnProperty(key)) {
        if (
          key === '_id' &&
          (typeof data._id === 'string' || data._id instanceof ObjectId)
        ) {
          data[key] = ObjectId.isValid(data._id?.toString())
            ? new ObjectId(data._id.toString())
            : new ObjectId(0);
        } else {
          if (key === '_id' && data._id?.$in?.length) {
            data._id = {
              $in: data._id.$in.map((id) => {
                return ObjectId.isValid(id.toString())
                  ? new ObjectId(id.toString())
                  : new ObjectId(0);
              }),
            };
          } else {
            data[key] = convertStringToObjectId(data[key]);
          }
        }
      }
    }
  } else if (Array.isArray(data)) {
    data = data.map((item) => convertStringToObjectId(item));
  }
  return data;
};

export const connect = async (dbName: string) => {
  try {
    const host = String(process.env.DB_URI).replace('{database}', '');
    return await new DbConnection(host, dbName).connect();
  } catch (error) {
    throw error;
  }
};

export const close = async (dbName: string, db: any) => {
  try {
    const host = String(process.env.DB_URI).replace('{database}', '');
    await new DbConnection(host, dbName).close(db);
  } catch (error) {
    throw error;
  }
};

export const findDocuments = async (
  db: mongoose.Connection,
  collectionName: string,
  query: object,
  fieldsToReturn: any = {},
  sort: any = {}
) => {
  try {
    let options : any = {};
    Object.keys(fieldsToReturn).length ? options['projection'] = fieldsToReturn : null;
    Object.keys(sort).length ? options['sort'] = sort : null;
    const dataResult = await db
      .collection(collectionName)
      .find(convertStringToObjectId(query), options);
    const result = await dataResult.toArray();

    return convertObjectIdToString(result);
  } catch (error) {
    throw error;
  }
};

export const findOneDocument = async (
  db: mongoose.Connection,
  collectionName: string,
  query: object,
  fieldsToReturn: any = {}
) => {
  try {
    const options = Object.keys(fieldsToReturn).length
      ? { projection: fieldsToReturn }
      : undefined;
    const result = await db
      .collection(collectionName)
      .findOne(convertStringToObjectId(query), options);
    return convertObjectIdToString(result);
  } catch (error) {
    throw error;
  }
};

export const findDocumentsByIdArray = async (
  db: mongoose.Connection,
  collectionName: string,
  idArray: string[],
  fieldsToReturn: any = {}
) => {
  try {
    const ids = idArray
      .map((id) =>
        ObjectId.isValid(id?.toString())
          ? new ObjectId(id?.toString())
          : undefined
      )
      .filter((id) => Boolean(id));
    const query = { _id: { $in: ids } };
    const options = Object.keys(fieldsToReturn).length
      ? { projection: fieldsToReturn }
      : undefined;
    const resultFind = await db
      .collection(collectionName)
      .find(query, options)
      
      const result = await resultFind.toArray();
    return convertObjectIdToString(result);
  } catch (error) {
    throw error;
  }
};

export const insertDocument = async (
  db: mongoose.Connection,
  collectionName: string,
  document: object
) => {
  return await db.collection(collectionName).insertOne(document);
};

export const updateDocument = async (
  db: mongoose.Connection,
  collectionName: string,
  query: object,
  update: object,
  options: mongoose.mongo.UpdateOptions = {}
) => {
  return await db.collection(collectionName).updateOne(convertStringToObjectId(query), update, options);
};

export const deleteDocument = async (
  db: mongoose.Connection,
  collectionName: string,
  query: object
) => {
  return await db.collection(collectionName).deleteOne(query);
};

export const aggregateDocuments = async (
  db: mongoose.Connection,
  collectionName: string,
  pipeline: object[]
) => {
  try {
    const queryObject = await db.collection(collectionName).aggregate(pipeline);
    const result = await queryObject.toArray();
    return convertObjectIdToString(result);
  } catch (error) {
    throw error;
  }
};

export const upsertDocument = async (
  db: mongoose.Connection,
  collectionName: string,
  query: object,
  update: object
) => {
  return await db
    .collection(collectionName)
    .updateOne(query, update, { upsert: true });
};

export const updateDocuments = async (
  db: mongoose.Connection,
  collectionName: string,
  query: object,
  update: object
) => {
  return await db.collection(collectionName).updateMany(query, update);
};

export const countDocuments = async (
  db: mongoose.Connection,
  collectionName: string,
  query: object
) => {
  try {
    return await db.collection(collectionName).countDocuments(query)
  } catch (error) {
    throw error;
  }
};

  export const findOneDocumentAndUpdate = async (
    db: mongoose.Connection,
    collectionName: string,
    query: object,
    update : object,
    filters : any = {} 
  ) => {
    try {
      return await db.collection(collectionName).findOneAndUpdate(convertStringToObjectId(query), update, filters)
    } catch (error) {
      throw error;
    }
  };

export const stringToObjectId = (string) => {
  return new ObjectId(string);
};

export const bulkWriteDocuments = async (
  db: mongoose.Connection,
  collectionName: string,
  operations: AnyBulkWriteOperation[],
  options: object = { ordered: false }
) => {
  return await db.collection(collectionName).bulkWrite(operations, options);
};

export const updateDocumentsWithOptions = async (
  db: mongoose.Connection,
  collectionName: string,
  query: object,
  update: object,
  options: object = {}
) => {
  return await db.collection(collectionName).updateMany(query, update, options);
};

export const findDocumentWithOptions = async (
  db: mongoose.Connection,
  collectionName: string,
  query: object,
  options: object = {}
) => {
  try {
    return await db.collection(collectionName).findOne(query , options)
  } catch (error) {
    throw error;
  }
};
export const deleteDocuments = async (
  db: mongoose.Connection,
  collectionName: string,
  query: object
) => {
  if (!query || Object.keys(query).length === 0) {
    throw new Error(`[deleteDocuments] existing and not empty query is required`);
  }
  return await db.collection(collectionName).deleteMany(query);
};