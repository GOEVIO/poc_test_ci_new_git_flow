import { Collection } from 'mongoose';
import {
  connect,
  findDocuments,
  findDocumentsByIdArray,
  findOneDocument,
  insertDocument,
  updateDocument,
  upsertDocument,
  aggregateDocuments,
  countDocuments
} from '../decorates/shared';
import { IMongoDBConnection } from '../interfaces/interfaces';

/**
 * This is supposed to works as a proxy for the db functions, and ensure there's
 * only a single instance for each database and help manage the connection object
 */
export class DbClient {
  static #instances: { [key: string]: DbClient } = {};

  #connection: IMongoDBConnection;

  private constructor(private dbName: string) {}

  /**
   * Here we ensure a single instance per database
   */
  public static getInstance(dbName: string) {
    if (!this.#instances.hasOwnProperty(dbName)) {
      this.#instances[dbName] = new DbClient(dbName);
    }
    return this.#instances[dbName];
  }

  /**
   * Here we ensure a single connection per instance
   */
  private async _getConnection(): Promise<IMongoDBConnection> {
    if (!this.#connection) {
      this.#connection = await connect(this.dbName);
    }
    return this.#connection;
  }

  /**
   * Gets an instance of a given collection in the current db
   */
  public async getCollection(collection: string): Promise<Collection> {
    const connection = await this._getConnection();
    return connection.db.collection(collection);
  }

  /**
   * Finds documents by query.
   *
   * @param {string} collectionName - name of collection used to do the search.
   * @param {object} query - The query to find the document to update.
   * @param {object} projection - The fields to project on the document.
   * @return {Promise<object[]>} An array of documents found, can be empty.
   * @throws on unexpected db connection error.
   */
  public async findMany(
    collectionName: string,
    query: object,
    projection?: object
  ): Promise<object[]> {
    try {
      const connection = await this._getConnection();
      return await findDocuments(
        connection.db,
        collectionName,
        query,
        projection
      );
    } catch (error) {
      console.error(`Error finding documents in database: ${error}`);
      throw error;
    }
  }

  /**
   * Finds documents by aggregated.
   *
   * @param {string} collectionName - name of collection used to do the search.
   * @param {object[]} pipeline - pipeline to aggregate the documents.
   * @return {Promise<object[]>} An array of documents found, can be empty.
   * @throws on unexpected db connection error.
   */
  public async findAggregated(
    collectionName: string,
    pipeline: object[]
  ): Promise<object[]> {
    try {
      const connection = await this._getConnection();
      return await aggregateDocuments(connection.db, collectionName, pipeline);
    } catch (error) {
      console.error(`Error finding documents in database: ${error}`);
      throw error;
    }
  }

  /**
   * Finds a document by query.
   *
   * @param {object} query - The query to find the document to update.
   * @return {Promise<object | undefined>} The first document found or undefined if none found.
   * @throws on unexpected db connection error.
   */
  public async findOne(
    collectionName: string,
    query: object,
    projection?: object
  ): Promise<object | undefined> {
    try {
      const connection = await this._getConnection();
      return await findOneDocument(
        connection.db,
        collectionName,
        query,
        projection
      );
    } catch (error) {
      console.error('Error finding one document in database: ', error);
      throw error;
    }
  }

  /**
   * Finds documents array by id array.
   *
   * @param {string[]} ids - The ids to find the documents.
   * @param {object} projection - The fields to project on the document.
   * @return {Promise<object[]>} Array of documents found, can be empty.
   * @throws on unexpected db connection error.
   */
  public async findManyByIdArray(
    collectionName: string,
    ids: string[],
    projection?: object
  ): Promise<object[]> {
    try {
      const connection = await this._getConnection();
      return await findDocumentsByIdArray(
        connection.db,
        collectionName,
        ids,
        projection
      );
    } catch (error) {
      console.error(
        'Error finding many documents by id array in database: ',
        ids,
        error
      );
      throw error;
    }
  }

  /**
   * Finds a document by id.
   *
   * @param {string} id - The id to find the document.
   * @param {object} projection - The fields to project on the document.
   * @return {Promise<object | undefined>} The first document found or undefined if none found.
   * @throws on unexpected db connection error.
   */
  public async findOneById(
    collectionName: string,
    id: string,
    projection?: object
  ): Promise<object | undefined> {
    try {
      return await this.findOne(collectionName, { _id: id }, projection);
    } catch (error) {
      console.error(
        'Error finding one document by id %s in database: ',
        id,
        error
      );
      throw error;
    }
  }

  /**
   * Inserts a document by query and updates by provided document.
   *
   * @param {object} document - The fields to update in the document.
   * @return {Promise<boolean>} A promise that resolves to true if a document was inserted, false else.
   */
  async insertOne(collectionName: string, document: object): Promise<boolean> {
    try {
      const connection = await this._getConnection();
      const result = await insertDocument(
        connection.db,
        collectionName,
        document
      );

      return result.acknowledged && !!result.insertedId;
    } catch (error) {
      console.error('Error inserting document in database: ', error);
      return false;
    }
  }

  /**
   * Finds a document by query and updates by provided document.
   *
   * @param {object} query - The query to find the document to update.
   * @param {object} document - The fields to update in the document.
   * @return {Promise<boolean>} A promise that resolves to true if a document was
   * found by the query independently if there was any update, or false else.
   */
  async updateOne(
    collectionName: string,
    query: object,
    document: object
  ): Promise<boolean> {
    try {
      const connection = await this._getConnection();
      const result = await updateDocument(
        connection.db,
        collectionName,
        query,
        document
      );

      return !!result.matchedCount;
    } catch (error) {
      console.error('Error updating document in database: ', error);
      return false;
    }
  }

  /**
   * Inserts or updates a document in the collection.
   *
   * @param {string} collectionName - The name of the collection to upsert in.
   * @param {object} query - The query to find the document to upsert.
   * @param {object} document - The document to insert or update.
   * @return {Promise<boolean>} A promise that resolves to true if the upsert was successful, false otherwise.
   */
  public async upsertOne(
    collectionName: string,
    query: object,
    document: object
  ): Promise<boolean> {
    try {
      const connection = await this._getConnection();
      const result = await upsertDocument(
        connection.db,
        collectionName,
        query,
        document
      );

      return result.upsertedCount > 0 || result.matchedCount > 0;
    } catch (error) {
      console.error('Error performing upsert operation in database: ', error);
      return false;
    }
  }

  /**
   * Counts the number of documents matching a specified query in a MongoDB collection.
   *
   * @param {string} collectionName - The name of the MongoDB collection to query.
   * @param {object} query - The query object to filter the documents.
   * @returns {Promise<number>} A promise that resolves to the count of matching documents.
   *                            Returns -1 if an error occurs during the operation.
   * @throws {Error} If there's an issue connecting to the database or executing the query.
   */
  public async count(collectionName: string, query: object): Promise<number> {
    try {
      const connection = await this._getConnection();
      const result = await countDocuments(
        connection.db,
        collectionName,
        query
      );

      return result;
    } catch (error) {
      console.error('Error count document in database: ', error);
      return -1;
    }
  }

}
