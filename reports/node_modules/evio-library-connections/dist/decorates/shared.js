"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteDocuments = exports.findDocumentWithOptions = exports.updateDocumentsWithOptions = exports.bulkWriteDocuments = exports.stringToObjectId = exports.findOneDocumentAndUpdate = exports.countDocuments = exports.updateDocuments = exports.upsertDocument = exports.aggregateDocuments = exports.deleteDocument = exports.updateDocument = exports.insertDocument = exports.findDocumentsByIdArray = exports.findOneDocument = exports.findDocuments = exports.close = exports.connect = void 0;
const mongodb_1 = require("mongodb");
const connect_1 = require("../commons/connect");
const convertObjectIdToString = (data) => {
    if (typeof data === 'object' && data !== null) {
        for (const key in data) {
            if (data.hasOwnProperty(key)) {
                if (key === '_id') {
                    data[key] = data._id?.toString();
                }
                else {
                    data[key] = convertObjectIdToString(data[key]);
                }
            }
        }
    }
    else if (Array.isArray(data)) {
        data = data.map((item) => convertObjectIdToString(item));
    }
    return data;
};
const convertStringToObjectId = (data) => {
    if (typeof data === 'object' && data !== null) {
        for (const key in data) {
            if (data.hasOwnProperty(key)) {
                if (key === '_id' &&
                    (typeof data._id === 'string' || data._id instanceof mongodb_1.ObjectId)) {
                    data[key] = mongodb_1.ObjectId.isValid(data._id?.toString())
                        ? new mongodb_1.ObjectId(data._id.toString())
                        : new mongodb_1.ObjectId(0);
                }
                else {
                    if (key === '_id' && data._id?.$in?.length) {
                        data._id = {
                            $in: data._id.$in.map((id) => {
                                return mongodb_1.ObjectId.isValid(id.toString())
                                    ? new mongodb_1.ObjectId(id.toString())
                                    : new mongodb_1.ObjectId(0);
                            }),
                        };
                    }
                    else {
                        data[key] = convertStringToObjectId(data[key]);
                    }
                }
            }
        }
    }
    else if (Array.isArray(data)) {
        data = data.map((item) => convertStringToObjectId(item));
    }
    return data;
};
const connect = async (dbName) => {
    try {
        const host = String(process.env.DB_URI).replace('{database}', '');
        return await new connect_1.DbConnection(host, dbName).connect();
    }
    catch (error) {
        throw error;
    }
};
exports.connect = connect;
const close = async (dbName, db) => {
    try {
        const host = String(process.env.DB_URI).replace('{database}', '');
        await new connect_1.DbConnection(host, dbName).close(db);
    }
    catch (error) {
        throw error;
    }
};
exports.close = close;
const findDocuments = async (db, collectionName, query, fieldsToReturn = {}, sort = {}) => {
    try {
        let options = {};
        Object.keys(fieldsToReturn).length ? options['projection'] = fieldsToReturn : null;
        Object.keys(sort).length ? options['sort'] = sort : null;
        const dataResult = await db
            .collection(collectionName)
            .find(convertStringToObjectId(query), options);
        const result = await dataResult.toArray();
        return convertObjectIdToString(result);
    }
    catch (error) {
        throw error;
    }
};
exports.findDocuments = findDocuments;
const findOneDocument = async (db, collectionName, query, fieldsToReturn = {}) => {
    try {
        const options = Object.keys(fieldsToReturn).length
            ? { projection: fieldsToReturn }
            : undefined;
        const result = await db
            .collection(collectionName)
            .findOne(convertStringToObjectId(query), options);
        return convertObjectIdToString(result);
    }
    catch (error) {
        throw error;
    }
};
exports.findOneDocument = findOneDocument;
const findDocumentsByIdArray = async (db, collectionName, idArray, fieldsToReturn = {}) => {
    try {
        const ids = idArray
            .map((id) => mongodb_1.ObjectId.isValid(id?.toString())
            ? new mongodb_1.ObjectId(id?.toString())
            : undefined)
            .filter((id) => Boolean(id));
        const query = { _id: { $in: ids } };
        const options = Object.keys(fieldsToReturn).length
            ? { projection: fieldsToReturn }
            : undefined;
        const resultFind = await db
            .collection(collectionName)
            .find(query, options);
        const result = await resultFind.toArray();
        return convertObjectIdToString(result);
    }
    catch (error) {
        throw error;
    }
};
exports.findDocumentsByIdArray = findDocumentsByIdArray;
const insertDocument = async (db, collectionName, document) => {
    return await db.collection(collectionName).insertOne(document);
};
exports.insertDocument = insertDocument;
const updateDocument = async (db, collectionName, query, update, options = {}) => {
    return await db.collection(collectionName).updateOne(convertStringToObjectId(query), update, options);
};
exports.updateDocument = updateDocument;
const deleteDocument = async (db, collectionName, query) => {
    return await db.collection(collectionName).deleteOne(query);
};
exports.deleteDocument = deleteDocument;
const aggregateDocuments = async (db, collectionName, pipeline) => {
    try {
        const queryObject = await db.collection(collectionName).aggregate(pipeline);
        const result = await queryObject.toArray();
        return convertObjectIdToString(result);
    }
    catch (error) {
        throw error;
    }
};
exports.aggregateDocuments = aggregateDocuments;
const upsertDocument = async (db, collectionName, query, update) => {
    return await db
        .collection(collectionName)
        .updateOne(query, update, { upsert: true });
};
exports.upsertDocument = upsertDocument;
const updateDocuments = async (db, collectionName, query, update) => {
    return await db.collection(collectionName).updateMany(query, update);
};
exports.updateDocuments = updateDocuments;
const countDocuments = async (db, collectionName, query) => {
    try {
        return await db.collection(collectionName).countDocuments(query);
    }
    catch (error) {
        throw error;
    }
};
exports.countDocuments = countDocuments;
const findOneDocumentAndUpdate = async (db, collectionName, query, update, filters = {}) => {
    try {
        return await db.collection(collectionName).findOneAndUpdate(convertStringToObjectId(query), update, filters);
    }
    catch (error) {
        throw error;
    }
};
exports.findOneDocumentAndUpdate = findOneDocumentAndUpdate;
const stringToObjectId = (string) => {
    return new mongodb_1.ObjectId(string);
};
exports.stringToObjectId = stringToObjectId;
const bulkWriteDocuments = async (db, collectionName, operations, options = { ordered: false }) => {
    return await db.collection(collectionName).bulkWrite(operations, options);
};
exports.bulkWriteDocuments = bulkWriteDocuments;
const updateDocumentsWithOptions = async (db, collectionName, query, update, options = {}) => {
    return await db.collection(collectionName).updateMany(query, update, options);
};
exports.updateDocumentsWithOptions = updateDocumentsWithOptions;
const findDocumentWithOptions = async (db, collectionName, query, options = {}) => {
    try {
        return await db.collection(collectionName).findOne(query, options);
    }
    catch (error) {
        throw error;
    }
};
exports.findDocumentWithOptions = findDocumentWithOptions;
const deleteDocuments = async (db, collectionName, query) => {
    if (!query || Object.keys(query).length === 0) {
        throw new Error(`[deleteDocuments] existing and not empty query is required`);
    }
    return await db.collection(collectionName).deleteMany(query);
};
exports.deleteDocuments = deleteDocuments;
//# sourceMappingURL=shared.js.map