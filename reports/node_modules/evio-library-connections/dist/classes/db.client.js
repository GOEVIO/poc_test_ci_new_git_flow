"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _a, _DbClient_instances, _DbClient_connection;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DbClient = void 0;
const shared_1 = require("../decorates/shared");
class DbClient {
    constructor(dbName) {
        this.dbName = dbName;
        _DbClient_connection.set(this, void 0);
    }
    static getInstance(dbName) {
        if (!__classPrivateFieldGet(this, _a, "f", _DbClient_instances).hasOwnProperty(dbName)) {
            __classPrivateFieldGet(this, _a, "f", _DbClient_instances)[dbName] = new _a(dbName);
        }
        return __classPrivateFieldGet(this, _a, "f", _DbClient_instances)[dbName];
    }
    async _getConnection() {
        if (!__classPrivateFieldGet(this, _DbClient_connection, "f")) {
            __classPrivateFieldSet(this, _DbClient_connection, await (0, shared_1.connect)(this.dbName), "f");
        }
        return __classPrivateFieldGet(this, _DbClient_connection, "f");
    }
    async getCollection(collection) {
        const connection = await this._getConnection();
        return connection.db.collection(collection);
    }
    async findMany(collectionName, query, projection) {
        try {
            const connection = await this._getConnection();
            return await (0, shared_1.findDocuments)(connection.db, collectionName, query, projection);
        }
        catch (error) {
            console.error(`Error finding documents in database: ${error}`);
            throw error;
        }
    }
    async findAggregated(collectionName, pipeline) {
        try {
            const connection = await this._getConnection();
            return await (0, shared_1.aggregateDocuments)(connection.db, collectionName, pipeline);
        }
        catch (error) {
            console.error(`Error finding documents in database: ${error}`);
            throw error;
        }
    }
    async findOne(collectionName, query, projection) {
        try {
            const connection = await this._getConnection();
            return await (0, shared_1.findOneDocument)(connection.db, collectionName, query, projection);
        }
        catch (error) {
            console.error('Error finding one document in database: ', error);
            throw error;
        }
    }
    async findManyByIdArray(collectionName, ids, projection) {
        try {
            const connection = await this._getConnection();
            return await (0, shared_1.findDocumentsByIdArray)(connection.db, collectionName, ids, projection);
        }
        catch (error) {
            console.error('Error finding many documents by id array in database: ', ids, error);
            throw error;
        }
    }
    async findOneById(collectionName, id, projection) {
        try {
            return await this.findOne(collectionName, { _id: id }, projection);
        }
        catch (error) {
            console.error('Error finding one document by id %s in database: ', id, error);
            throw error;
        }
    }
    async insertOne(collectionName, document) {
        try {
            const connection = await this._getConnection();
            const result = await (0, shared_1.insertDocument)(connection.db, collectionName, document);
            return result.acknowledged && !!result.insertedId;
        }
        catch (error) {
            console.error('Error inserting document in database: ', error);
            return false;
        }
    }
    async updateOne(collectionName, query, document) {
        try {
            const connection = await this._getConnection();
            const result = await (0, shared_1.updateDocument)(connection.db, collectionName, query, document);
            return !!result.matchedCount;
        }
        catch (error) {
            console.error('Error updating document in database: ', error);
            return false;
        }
    }
    async upsertOne(collectionName, query, document) {
        try {
            const connection = await this._getConnection();
            const result = await (0, shared_1.upsertDocument)(connection.db, collectionName, query, document);
            return result.upsertedCount > 0 || result.matchedCount > 0;
        }
        catch (error) {
            console.error('Error performing upsert operation in database: ', error);
            return false;
        }
    }
    async count(collectionName, query) {
        try {
            const connection = await this._getConnection();
            const result = await (0, shared_1.countDocuments)(connection.db, collectionName, query);
            return result;
        }
        catch (error) {
            console.error('Error count document in database: ', error);
            return -1;
        }
    }
}
exports.DbClient = DbClient;
_a = DbClient, _DbClient_connection = new WeakMap();
_DbClient_instances = { value: {} };
//# sourceMappingURL=db.client.js.map