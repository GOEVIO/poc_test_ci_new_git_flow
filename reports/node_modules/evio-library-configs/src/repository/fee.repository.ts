
import { ConfigsDbConnection } from '../common/configsDb.connection'
import { Fee, FeeSchema } from '../schema/fee.schema'

class FeeRepository {
  static #instance: FeeRepository
  #client = ConfigsDbConnection
  #collectionName = 'fees'

  private constructor() {}

  public static get instance(): FeeRepository {
    if (!FeeRepository.#instance) {
      FeeRepository.#instance = new FeeRepository()
    }
    return FeeRepository.#instance
  }

  /**
   * Find one Fee document by country code
   * @param {string} countryCode
   * @return {Fee | undefined} the found document or undefined if none found or malformed found
   * @throw on db conection error
   */
  public async findOneByCountryCode(
    countryCode: string
  ): Promise<Fee | undefined> {
    const document = await this.#client.findOne(this.#collectionName, {
      countryCode,
    })
    const wrapper = FeeSchema.safeParse(document)
    if (!wrapper.success) {
      console.log('not found or malformed fee', wrapper.error)
      return undefined
    }
    return wrapper.data
  }

  /**
   * Find one Fee document by country code and zone
   * @param {string} countryCode
   * @param {string} zone
   * @return {Fee | undefined} the found document or undefined if none found or malformed found
   * @throw on db conection error
   */
  public async findOneByCountryCodeAndZone(
    countryCode: string,
    zone: string
  ): Promise<Fee | undefined> {
    const document = await this.#client.findOne(this.#collectionName, {
      countryCode,
      zone,
    })
    const wrapper = FeeSchema.safeParse(document)
    if (!wrapper.success) {
      console.log('not found or malformed fee', wrapper.error)
      return undefined
    }
    return wrapper.data
  }
}

export const FeeReadRepository = FeeRepository.instance
