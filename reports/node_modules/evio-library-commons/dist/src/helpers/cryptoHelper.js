"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const encrypt = (data, secret) => {
    try {
        const iv = crypto_1.default.randomBytes(12);
        const cipher = crypto_1.default.createCipheriv('aes-256-gcm', secret, iv);
        const json = JSON.stringify(data);
        let encrypted = cipher.update(json, 'utf8', 'base64');
        encrypted += cipher.final('base64');
        const authTag = cipher.getAuthTag();
        const payload = {
            iv: iv.toString('base64'),
            data: encrypted,
            tag: authTag.toString('base64'),
        };
        return Buffer.from(JSON.stringify(payload)).toString('base64url');
    }
    catch (error) {
        console.error("Error while generating hash link:", error);
        return null;
    }
};
const decrypt = (token, secret) => {
    try {
        const raw = JSON.parse(Buffer.from(token, 'base64url').toString('utf8'));
        const iv = Buffer.from(raw.iv, 'base64');
        const tag = Buffer.from(raw.tag, 'base64');
        const decipher = crypto_1.default.createDecipheriv('aes-256-gcm', secret, iv);
        decipher.setAuthTag(tag);
        let decrypted = decipher.update(raw.data, 'base64', 'utf8');
        decrypted += decipher.final('utf8');
        return JSON.parse(decrypted);
    }
    catch (error) {
        console.error("Error while decrypting token:", error);
        return null;
    }
};
const createHash = (data, length = 40) => {
    return crypto_1.default.createHash('SHA256').update(data).digest('hex').substring(0, length).toUpperCase();
};
const scryptSync = (password, salt, keylen = 32) => {
    return crypto_1.default.scryptSync(password, salt, keylen);
};
exports.default = {
    encrypt,
    decrypt,
    createHash,
    scryptSync
};
//# sourceMappingURL=cryptoHelper.js.map