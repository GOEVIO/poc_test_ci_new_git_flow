import crypto from "crypto";
import fs from "fs/promises";
import path from "path";
import { filePaths } from "../constants";

export const randomName = (ext = "") =>
    `${Date.now()}_${crypto.randomBytes(6).toString("hex")}${ext ? "." + ext : ""}`;

export const parseDataUrl = (input: string) => {
    const hasHeader = input.startsWith("data:");
    if (!hasHeader) return { contentType: "application/octet-stream", base64: input };

    const match = input.match(/^data:([^;]+);base64,(.+)$/);
    if (!match) throw new Error("Invalid data URL");
    const [, meta, b64] = match;
    return { contentType: meta, base64: b64 };
};

export const extFromContentType = (ct?: string) => {
    if (!ct) return "";
    const map: Record<string, string> = {
        "image/png": ".png",
        "image/jpeg": ".jpg",
        "image/jpg": ".jpg",
        "image/webp": ".webp",
        "image/svg+xml": ".svg",
    };
    return map[ct] || "";
};

/** Extract key from a public URL */
export const keyFromUrl = (url: string) => {
    const base = filePaths.root.url;
    const prefix = base.endsWith("/") ? base : base + "/";
    if (!url.startsWith(prefix)) throw new Error(`URL does not start with ${prefix}`);
    return url.substring(prefix.length);
};

/** Discover file type from a URL */
export function getFileTypeFromUrl(url: string): keyof typeof filePaths {
  const entry = Object.entries(filePaths).find(([_, val]) =>
    url.startsWith(val.url)
  );
  return (entry?.[0] as keyof typeof filePaths) ?? "root";
}

/** Create directories recursively */
export const ensureDir = async (dir: string) => {
    await fs.mkdir(path.resolve(dir), { recursive: true });
};

/** Ensure key resolves to a path inside the root directory */
export const safeJoin = (root: string, key: string) => {
    const p = path.resolve(root, key);
    const rootNorm = path.resolve(root) + path.sep;
    if (!p.startsWith(rootNorm)) throw new Error("Invalid key path");
    return p;
};
