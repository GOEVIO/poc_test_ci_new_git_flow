"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileTransaction = void 0;
const evio_library_commons_1 = __importDefault(require("evio-library-commons"));
const axios_1 = __importDefault(require("axios"));
const object_hash_1 = __importDefault(require("object-hash"));
const evio_redis_connection_1 = __importDefault(require("evio-redis-connection"));
const translation_context_class_1 = __importDefault(require("./classes/translation-context.class"));
const redis_strategy_class_1 = __importDefault(require("./classes/redis-strategy.class"));
const weblate_strategy_class_1 = __importDefault(require("./classes/weblate-strategy.class"));
const { ErrorHandlerCommon, Enums } = evio_library_commons_1.default;
const { StatusCodeHttp, ClientNames } = Enums;
const headers = {
    Authorization: `Token ${process.env.WEBLATE_TOKEN}`,
    Host: 'tms.go-evio.com',
    accept: 'application/json',
};
class FileTransaction {
}
exports.FileTransaction = FileTransaction;
_a = FileTransaction;
FileTransaction.defaultProject = ClientNames.EVIO.toLowerCase() || 'evio';
FileTransaction.defaultLang = process.env.DEFAULT_LANGUAGE || 'en';
FileTransaction.defaultComponent = process.env.DEFAULT_COMPONENT || 'shared';
FileTransaction.redisClient = evio_redis_connection_1.default.connect();
FileTransaction.retrieveFileTranslationMetadata = async (device, project) => {
    const context = 'retrieveFileTranslationMetadata';
    try {
        const host = `${process.env.WEBLATE_HOST}/components/${_a.defaultProject}/${device || _a.defaultComponent}/translations/`;
        const translation = await axios_1.default.get(host, { headers });
        if (translation === undefined || translation.data.length === 0) {
            throw ErrorHandlerCommon.NotFound({
                auth: false,
                code: 'server_component_not_found',
                message: 'Component language file not found',
            }, context);
        }
        return translation.data;
    }
    catch (error) {
        console.error(`[${context}] Error: ${error.message}`);
        if (error?.status === StatusCodeHttp.NOT_FOUND) {
            throw ErrorHandlerCommon.NotFound({
                auth: false,
                code: 'server_component_not_found',
                message: 'Component language file not found',
            }, context);
        }
        throw ErrorHandlerCommon.ServerError({
            auth: false,
            code: 'server_internal_error',
            message: error.message || 'Internal server error',
        }, context);
    }
};
FileTransaction.retrieveFileTranslationWithRetry = async (strategy, data, maxRetries = 3) => {
    const context = 'retrieveFileTranslationWithRetry';
    let retryCount = 0;
    let language = data?.language || _a.defaultLang;
    const component = data?.component || _a.defaultComponent;
    const project = data?.project || _a.defaultProject;
    let result;
    console.info(`[${context}] - Attempting to retrieve translation for component: ${component}, language: ${language}, project: ${project}`);
    while (retryCount <= maxRetries) {
        try {
            if (retryCount === 1) {
                language = `${language.split('_')[0]}_${language.split('_')[0].toUpperCase()}`;
            }
            if (retryCount === 2) {
                language = `${language.split('_')[0]}`;
            }
            if (retryCount === 3) {
                language = _a.defaultLang;
            }
            const redisKey = `translation:${_a.defaultProject}:${component}:${language}`;
            const context = new translation_context_class_1.default(strategy);
            result = await context.executeStrategy(redisKey, {
                headers,
                host: `${process.env.WEBLATE_HOST}/translations/${_a.defaultProject}/${component}/${language}/file/`,
            });
            return result;
        }
        catch (error) {
            console.error(`[${context}] Attempt ${retryCount + 1} Error: ${error?.message || JSON.stringify(error)}`);
            retryCount++;
            if (retryCount <= maxRetries) {
                await new Promise((resolve) => setTimeout(resolve, 500));
            }
            if (retryCount > maxRetries) {
                if (strategy instanceof weblate_strategy_class_1.default) {
                    console.info(`[${context}] - Attempting to retrieve from Redis with default language`);
                    await _a.retrieveFileTranslationWithRetry(new redis_strategy_class_1.default(), { component: data.component, language: _a.defaultLang }, 0);
                }
                console.error(`[${context}] Max retries reached. Throwing error: ${error?.message || error?.error?.message || JSON.stringify(error)}`);
                throw error;
            }
        }
    }
};
FileTransaction.retrieveFileTranslationByLanguage = async (data) => {
    const context = 'retrieveFileTranslationByLanguage';
    try {
        console.info(`[${context}] - Attempting to retrieve from Redis`);
        return await _a.retrieveFileTranslationWithRetry(new redis_strategy_class_1.default(), data, 2);
    }
    catch (error) {
        console.info(`[${context}] ${error.message} - Attempting to retrieve from Weblate`);
        return await _a.retrieveFileTranslationWithRetry(new weblate_strategy_class_1.default(), data, 3);
    }
};
FileTransaction.setupHashTranslation = async (translation) => {
    const context = 'setupHashTranslation';
    try {
        return { translationHash: await (0, object_hash_1.default)(translation) };
    }
    catch (error) {
        console.error(`[${context}] Error: ${error.message}`);
        throw error;
    }
};
FileTransaction.retriveFileTransactionAsHash = async (data) => {
    const context = 'retriveFileTransactionAsHash';
    try {
        console.log(`[${context}] data`, data);
        let transaction = await _a.retrieveFileTranslationByLanguage(data);
        return await _a.setupHashTranslation(transaction);
    }
    catch (error) {
        console.error(`[${context}] Error: ${error.message}`);
        throw error;
    }
};
FileTransaction.retrieveMessageTranslation = async (data, key) => {
    const context = 'retrieveMessageTranslation';
    try {
        console.log(`[${context}] data: ${JSON.stringify(data)}, key: ${key}`);
        let transaction = await _a.retrieveFileTranslationByLanguage(data);
        let message = transaction[key];
        return message || '';
    }
    catch (error) {
        console.error(`[${context}] Error: ${error.message || error}`);
        throw error;
    }
};
//# sourceMappingURL=file.transalaction.js.map