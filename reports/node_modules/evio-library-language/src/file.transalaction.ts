import libraryCommons from 'evio-library-commons';
import axios from 'axios';
import hash from 'object-hash';
import { IRequestTranslation } from '../schema_interfaces/translations.interface';
import RedisConnection from 'evio-redis-connection';
import TranslationContext from './classes/translation-context.class';
import ConcreteStrategyRedis from './classes/redis-strategy.class';
import ConcreteStrategyWeblate from './classes/weblate-strategy.class';
import ITranslationStrategy from './interfaces/translation-strategy.interface';

const { ErrorHandlerCommon, Enums } = libraryCommons;
const { StatusCodeHttp, ClientNames } = Enums;

const headers = {
  Authorization: `Token ${process.env.WEBLATE_TOKEN}`,
  Host: 'tms.go-evio.com',
  accept: 'application/json',
};

export class FileTransaction {
  static defaultProject = ClientNames.EVIO.toLowerCase() || 'evio';
  static defaultLang = (process.env.DEFAULT_LANGUAGE as string) || 'en';
  static defaultComponent =
    (process.env.DEFAULT_COMPONENT as string) || 'shared';
  static redisClient = RedisConnection.connect();

  static retrieveFileTranslationMetadata = async (
    device: string,
    project: string
  ) => {
    const context = 'retrieveFileTranslationMetadata';
    try {
      const host = `${process.env.WEBLATE_HOST}/components/${
        this.defaultProject
      }/${device || this.defaultComponent}/translations/`;

      const translation = await axios.get(host, { headers });

      if (translation === undefined || translation.data.length === 0) {
        throw ErrorHandlerCommon.NotFound(
          {
            auth: false,
            code: 'server_component_not_found',
            message: 'Component language file not found',
          },
          context
        );
      }

      return translation.data;
    } catch (error) {
      console.error(`[${context}] Error: ${error.message}`);

      if (error?.status === StatusCodeHttp.NOT_FOUND) {
        throw ErrorHandlerCommon.NotFound(
          {
            auth: false,
            code: 'server_component_not_found',
            message: 'Component language file not found',
          },
          context
        );
      }
      throw ErrorHandlerCommon.ServerError(
        {
          auth: false,
          code: 'server_internal_error',
          message: error.message || 'Internal server error',
        },
        context
      );
    }
  };

  private static retrieveFileTranslationWithRetry = async (
    strategy: ITranslationStrategy,
    data: IRequestTranslation,
    maxRetries: number = 3
  ) => {
    const context = 'retrieveFileTranslationWithRetry';
    let retryCount = 0;

    let language = data?.language || this.defaultLang;
    const component = data?.component || this.defaultComponent;
    const project = data?.project || this.defaultProject;

    let result;

    console.info(
      `[${context}] - Attempting to retrieve translation for component: ${component}, language: ${language}, project: ${project}`
    );

    while (retryCount <= maxRetries) {
      try {
        if (retryCount === 1) {
          language = `${language.split('_')[0]}_${language.split('_')[0].toUpperCase()}`;
        }

        if (retryCount === 2) {
          language = `${language.split('_')[0]}`;
        }

        if (retryCount === 3) {
          language = this.defaultLang;
        }

        const redisKey = `translation:${this.defaultProject}:${component}:${language}`;
        const context = new TranslationContext(strategy);

        result = await context.executeStrategy(redisKey, {
          headers,
          host: `${process.env.WEBLATE_HOST}/translations/${this.defaultProject}/${component}/${language}/file/`,
        });
        return result;
      } catch (error) {
        console.error(
          `[${context}] Attempt ${retryCount + 1} Error: ${error?.message || JSON.stringify(error)}`
        );

        retryCount++;

        // Wait a bit before retrying (optional)
        if (retryCount <= maxRetries) {
          await new Promise((resolve) => setTimeout(resolve, 500));
        }

        if (retryCount > maxRetries) {

          if(strategy instanceof ConcreteStrategyWeblate) {
            console.info(
              `[${context}] - Attempting to retrieve from Redis with default language`
            );
            
            await this.retrieveFileTranslationWithRetry(new ConcreteStrategyRedis(), {component: data.component, language: this.defaultLang}, 0);
          }

          console.error(
            `[${context}] Max retries reached. Throwing error: ${error?.message || error?.error?.message || JSON.stringify(error)}`
          );

          throw error;
        }
      }
    }
  };

  static retrieveFileTranslationByLanguage = async (
    data: IRequestTranslation
  ) => {
    const context = 'retrieveFileTranslationByLanguage';
    try {
      console.info(`[${context}] - Attempting to retrieve from Redis`);
      return await this.retrieveFileTranslationWithRetry(
        new ConcreteStrategyRedis(),
        data,
        2
      );
    } catch (error) {
      console.info(
        `[${context}] ${error.message} - Attempting to retrieve from Weblate`
      );
      return await this.retrieveFileTranslationWithRetry(
        new ConcreteStrategyWeblate(),
        data,
        3
      );
    }
  };

  static setupHashTranslation = async (translation: Object) => {
    const context = 'setupHashTranslation';
    try {
      return { translationHash: await hash(translation) };
    } catch (error) {
      console.error(`[${context}] Error: ${error.message}`);
      throw error;
    }
  };

  static retriveFileTransactionAsHash = async (data: IRequestTranslation) => {
    const context = 'retriveFileTransactionAsHash';
    try {
      console.log(`[${context}] data`, data);
      let transaction = await this.retrieveFileTranslationByLanguage(data);
      return await this.setupHashTranslation(transaction);
    } catch (error) {
      console.error(`[${context}] Error: ${error.message}`);
      throw error;
    }
  };

  static retrieveMessageTranslation = async (
    data: IRequestTranslation,
    key: string
  ) => {
    const context = 'retrieveMessageTranslation';
    try {
      console.log(`[${context}] data: ${JSON.stringify(data)}, key: ${key}`);

      let transaction = await this.retrieveFileTranslationByLanguage(data);
      let message = transaction[key];

      return message || '';
    } catch (error) {
      console.error(`[${context}] Error: ${error.message || error}`);
      throw error;
    }
  };
}
