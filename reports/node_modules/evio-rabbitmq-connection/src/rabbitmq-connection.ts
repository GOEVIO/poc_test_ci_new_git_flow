import client, { Connection, Channel } from "amqplib";
import { DEFAULT_LIMIT_TO_PROCESS_LETTER_SIMULTANEOUSLY, rmqPass, rmqUser, rmqhost } from './constants';
import { IAssertQueueConfig, IAssertQueueParams, IConsumeParams, IHandleErrorParams } from './interfaces'
import { sentryInit } from "./sentryInit";
import { captureException } from '@sentry/node';

class RabbitMQConnection {
  connection!: Connection;
  channel!: Channel;
  private connected!: Boolean;

  async connect() {
    if (this.connected && this.channel) return;

    console.log(`⌛️ Connecting to Rabbit-MQ Server`);

    this.connection = await client.connect(
      `amqp://${rmqUser}:${rmqPass}@${rmqhost}:5672`
    );

    console.log(`✅ Rabbit MQ Connection is ready`);

    this.channel = await this.connection.createChannel();

    console.log(`🛸 Created RabbitMQ Channel successfully`);

    this.connected = true;
    sentryInit();
  }

  async assertQueue(params: IAssertQueueParams) {
    const assertQueueConfig: IAssertQueueConfig = {
      durable: params.durable
    }
    if (params?.deadLetterExchange && params?.deadQueue) {
      await Promise.all([
        this.channel.assertExchange(params.deadLetterExchange, "direct", assertQueueConfig),
        this.channel.assertQueue(params.deadQueue, assertQueueConfig),
        this.channel.bindQueue(params.deadQueue, params.deadLetterExchange, params.deadQueue),
      ])
      assertQueueConfig.arguments = {
        "x-dead-letter-exchange": params.deadLetterExchange,
        "x-dead-letter-routing-key": params.deadQueue
      }
    }

    await this.channel.assertQueue(params.queueName, assertQueueConfig)
  }

  async consume(consumerParams: IConsumeParams) {
    const maxRetries = consumerParams?.maxRetries || 0;

    if (!this.channel) {
      await this.connect();
    }

    this.channel.prefetch(consumerParams?.limitToProcess || DEFAULT_LIMIT_TO_PROCESS_LETTER_SIMULTANEOUSLY);

    const deadLetterExchange = consumerParams?.deadLetterExchange || '';
    const deadQueue = consumerParams?.deadQueue || '';

    await this.assertQueue({
      durable: true,
      queueName: consumerParams.queue,
      deadLetterExchange,
      deadQueue
    })

    this.channel.consume(
      consumerParams.queue,
      async (msg) => {
        if (!msg) {
          return console.error(`Invalid incoming message`);
        }
        try {
          const parsedMessage = JSON.parse(msg.content.toString());
          await consumerParams.handleIncomingMessage(parsedMessage);
          this.channel.ack(msg);

        }
        catch (error) {
          if (maxRetries > 0) {
            this.handleQueueError({
              error: (error as Error),
              maxRetries,
              msg,
              queue: consumerParams.queue,
              deadLetterExchange,
              deadQueue,
            })

          } else {
            await this.sendAlertToBackendTeam(`Queue: ${consumerParams.queue} <br> With no retries <br> Error: ${JSON.stringify(error, null, 4)}
            `, consumerParams.teamsWebhookUrl)
            this.channel.ack(msg);
          }
        }
      },
      {
        noAck: false,
      }
    );
  }

  async handleQueueError(params: IHandleErrorParams) {
    try {
      const parsedMessage = JSON.parse(params.msg.content.toString());
      const timesTried = (parsedMessage.timesTried || 0) + 1;
      const errors: string[] = parsedMessage.errors || []
      errors.push(params.error.toString());

      if (timesTried > params.maxRetries) {
        console.error(params.error);
        captureException(params.error);
        if (params?.deadQueue && params?.deadLetterExchange) {
          const errorHeaders = {
            "error_reason": "max_retries_reached",
            "original_error": params.error.toString()
          };

          this.channel.nack(params.msg, false, false);
          this.channel.publish(params.deadLetterExchange, params.deadQueue, params.msg.content, {
            headers: {
              ...params.msg.properties.headers,
              ...errorHeaders
            }
          });
        } else {
          this.channel.ack(params.msg);
        }

      } else {

        await this.sendToQueue(
          params.queue,
          {
            ...parsedMessage,
            timesTried,
            errors
          }
        );

        this.channel.ack(params.msg);
      }
    } catch (error) {
      this.channel.ack(params.msg);
      console.error(error);
      captureException(error);
    }
   
  }

  async sendToQueue(queue: string, message: any) {
    if (!this.channel) {
      await this.connect();
    }

    this.channel.sendToQueue(queue, Buffer.from(JSON.stringify(message)), { persistent: true, deliveryMode: 2 });
  }

  async sendAlertToBackendTeam(text: string, teamsWebhookUrl: string) {
    return await fetch(teamsWebhookUrl, { method: 'POST', body: JSON.stringify({ text }) });
  }
}

const mqConnection = new RabbitMQConnection();

export default mqConnection;