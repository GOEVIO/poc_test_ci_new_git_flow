"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const amqplib_1 = __importDefault(require("amqplib"));
const constants_1 = require("./constants");
const sentryInit_1 = require("./sentryInit");
const node_1 = require("@sentry/node");
class RabbitMQConnection {
    async connect() {
        if (this.connected && this.channel)
            return;
        console.log(`âŒ›ï¸ Connecting to Rabbit-MQ Server`);
        this.connection = await amqplib_1.default.connect(`amqp://${constants_1.rmqUser}:${constants_1.rmqPass}@${constants_1.rmqhost}:5672`);
        console.log(`âœ… Rabbit MQ Connection is ready`);
        this.channel = await this.connection.createChannel();
        console.log(`ðŸ›¸ Created RabbitMQ Channel successfully`);
        this.connected = true;
        (0, sentryInit_1.sentryInit)();
    }
    async assertQueue(params) {
        const assertQueueConfig = {
            durable: params.durable
        };
        if (params?.deadLetterExchange && params?.deadQueue) {
            await Promise.all([
                this.channel.assertExchange(params.deadLetterExchange, "direct", assertQueueConfig),
                this.channel.assertQueue(params.deadQueue, assertQueueConfig),
                this.channel.bindQueue(params.deadQueue, params.deadLetterExchange, params.deadQueue),
            ]);
            assertQueueConfig.arguments = {
                "x-dead-letter-exchange": params.deadLetterExchange,
                "x-dead-letter-routing-key": params.deadQueue
            };
        }
        await this.channel.assertQueue(params.queueName, assertQueueConfig);
    }
    async consume(consumerParams) {
        const maxRetries = consumerParams?.maxRetries || 0;
        if (!this.channel) {
            await this.connect();
        }
        this.channel.prefetch(consumerParams?.limitToProcess || constants_1.DEFAULT_LIMIT_TO_PROCESS_LETTER_SIMULTANEOUSLY);
        const deadLetterExchange = consumerParams?.deadLetterExchange || '';
        const deadQueue = consumerParams?.deadQueue || '';
        await this.assertQueue({
            durable: true,
            queueName: consumerParams.queue,
            deadLetterExchange,
            deadQueue
        });
        this.channel.consume(consumerParams.queue, async (msg) => {
            if (!msg) {
                return console.error(`Invalid incoming message`);
            }
            try {
                const parsedMessage = JSON.parse(msg.content.toString());
                await consumerParams.handleIncomingMessage(parsedMessage);
                this.channel.ack(msg);
            }
            catch (error) {
                if (maxRetries > 0) {
                    this.handleQueueError({
                        error: error,
                        maxRetries,
                        msg,
                        queue: consumerParams.queue,
                        deadLetterExchange,
                        deadQueue,
                    });
                }
                else {
                    await this.sendAlertToBackendTeam(`Queue: ${consumerParams.queue} <br> With no retries <br> Error: ${JSON.stringify(error, null, 4)}
            `, consumerParams.teamsWebhookUrl);
                    this.channel.ack(msg);
                }
            }
        }, {
            noAck: false,
        });
    }
    async handleQueueError(params) {
        try {
            const parsedMessage = JSON.parse(params.msg.content.toString());
            const timesTried = (parsedMessage.timesTried || 0) + 1;
            const errors = parsedMessage.errors || [];
            errors.push(params.error.toString());
            if (timesTried > params.maxRetries) {
                console.error(params.error);
                (0, node_1.captureException)(params.error);
                if (params?.deadQueue && params?.deadLetterExchange) {
                    const errorHeaders = {
                        "error_reason": "max_retries_reached",
                        "original_error": params.error.toString()
                    };
                    this.channel.nack(params.msg, false, false);
                    this.channel.publish(params.deadLetterExchange, params.deadQueue, params.msg.content, {
                        headers: {
                            ...params.msg.properties.headers,
                            ...errorHeaders
                        }
                    });
                }
                else {
                    this.channel.ack(params.msg);
                }
            }
            else {
                await this.sendToQueue(params.queue, {
                    ...parsedMessage,
                    timesTried,
                    errors
                });
                this.channel.ack(params.msg);
            }
        }
        catch (error) {
            this.channel.ack(params.msg);
            console.error(error);
            (0, node_1.captureException)(error);
        }
    }
    async sendToQueue(queue, message) {
        if (!this.channel) {
            await this.connect();
        }
        this.channel.sendToQueue(queue, Buffer.from(JSON.stringify(message)), { persistent: true, deliveryMode: 2 });
    }
    async sendAlertToBackendTeam(text, teamsWebhookUrl) {
        return await fetch(teamsWebhookUrl, { method: 'POST', body: JSON.stringify({ text }) });
    }
}
const mqConnection = new RabbitMQConnection();
exports.default = mqConnection;
//# sourceMappingURL=rabbitmq-connection.js.map